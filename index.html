<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Amit Kumar Yadav</title>
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>

<body>
  <div id="wrapper">
    <!-- Navbar -->
    <div class="container">
      <div class="navbar">
        <div class="logo-container">
          <img src="./Assets/A.png" class="logo" alt="Logo">
          <div class="logo-text">mit Kumar Yadav</div>
        </div>

        <div class="nav-items">
          <div><a href="#about">About</a></div>
          <div><a href="#skills">Skills</a></div>
          <div><a href="#projects">Projects</a></div>
          <div><a href="#experience">Experience</a></div>
          <div><a href="#certifications">Certifications</a></div>
          <div><a href="#contact">Contact</a></div>
        </div>
      </div>
    </div>

    <!-- Hero Section -->
    <div class="hero-section">
      <div class="faded-text">Amit Yadav</div>

      <div class="hero-section-left">
        <div class="hero-section-heading">Hello 👋</div>
        <div class="hero-section-subheading1">I am</div>
        <div class="hero-section-subheading2">Amit Kumar Yadav</div>
        <div class="hero-section-subheading3">
          I am a <span class="role"></span>
        </div>

        <div class="hero-section-description">
          A final-year student passionate about
        </div>
        <div>
          <span class="dynamic-text"></span>
        </div>

        <div class="btn-pink" id="btn">Hire me</div>
      </div>

 <div class="hero-section-right">
                    <div class="absolute icons icon-dots">
                        <img src="./Assets/dots.png" alt="" />
                      </div>
                      <div class="absolute icons icon-cube">
                        <img src="./Assets/cube.png" alt="" />
                      </div>
                      <div class="absolute icons icon-circle">
                        <img src="./Assets/circle.png" alt="" />
                      </div>
                      <div class="absolute icons icon-zigzag">
                        <img src="./Assets/zigzags.png" alt="" />
                      </div>
                      <div class="absolute icons icon-plus">
                        <img src="./Assets/plus.png" alt="" />
                      </div>
                      <div class="user-image">
                        <img src="./Assets/Amit1.jpeg" alt="" />
                      </div>
                </div>

</div>




  <div class="section-decor before">
    <div class="curve left"></div>
    <div class="curve right"></div>
  </div>

  <div id="about" class="section-with-curves"></div>

  <div class="section-decor between">
    <div class="curve left"></div>
    <div class="curve right"></div>
  </div>

  <div id="skills" class="section-with-curves"></div>

  <div class="section-decor between">
    <div class="curve left"></div>
    <div class="curve right"></div>
  </div>

  <div id="projects" class="section-with-curves"></div>

  <div class="section-decor after">
    <div class="curve left"></div>
    <div class="curve right"></div>
  </div>

  

  <!-- Popup Modal -->
  <div class="modal" style="display: none;">
    <div class="modal-content">
      <span class="close-btn">&times;</span>
      <h2 id="modal-title"></h2>
      <h4>Description</h4>
      <p id="modal-desc"></p>
    </div>
  </div>
    <div id="experience" class="section-with-curves"></div>

    <div id="certifications"></div>
    <section id="contact"></section>


  <!-- Typed.js Animation -->
  <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12"></script>
  <script>
    // (removed) previously we forced scroll-to-top on load which prevented restoring hashed navigation on refresh

    var typed = new Typed(".dynamic-text", {
      strings: [
        "Machine Learning",
        "AI",
        "Automation",
        "Cloud Computing",
        "Python Development"
      ],
      loop: true,
      typeSpeed: 100,
      backSpeed: 60,
      backDelay: 1000,
      showCursor: true,
      cursorChar: "|"
    });


fetch("about.html")
  .then(response => response.text())
  .then(data => {
    document.getElementById("about").innerHTML = data;

    // When clicking the About nav link, scroll the about card to the center of the viewport
    function scrollAboutCenter() {
      const about = document.getElementById('about');
      if (!about) return;
      const card = about.querySelector('.about-card') || about;
      // Use scrollIntoView so it scrolls the nearest scrollable ancestor (the #wrapper)
      card.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
      // focus for accessibility (preventScroll true to avoid jumping)
      try {
        card.setAttribute('tabindex', '-1');
        card.focus({ preventScroll: true });
      } catch (e) {
        // older browsers may not support options
        card.focus();
      }
    }

    const aboutLink = document.querySelector('a[href="#about"]');
    if (aboutLink) {
      aboutLink.addEventListener('click', e => {
        e.preventDefault();
        const about = document.getElementById('about');
        if (about && about.querySelector('.about-card')) {
          scrollAboutCenter();
        } else {
          // wait until about content is inserted
          const obs = new MutationObserver((mutations, observer) => {
            if (about.querySelector('.about-card')) {
              scrollAboutCenter();
              observer.disconnect();
            }
          });
          obs.observe(about, { childList: true, subtree: true });
        }
      });
    }
    window.location.hash = "#about";
  })

  

fetch("projects.html")
  .then(response => response.text())
  .then(data => {
    document.getElementById("projects").innerHTML = data;
    // Initialize modal functionality
    const modal = document.querySelector(".modal");
    const modalTitle = document.getElementById("modal-title");
    const modalDesc = document.getElementById("modal-desc");
    const closeBtn = document.querySelector(".close-btn");

    document.querySelectorAll(".view-btn").forEach(btn => {
      btn.addEventListener("click", e => {
        e.preventDefault();
        const card = e.target.closest(".card");
        try {
          scrollProjectsCenter(card, -100);
          // Give the smooth scroll a moment to start/complete visually before showing the modal.
          setTimeout(() => {
            modalTitle.textContent = card.getAttribute("data-title");
            modalDesc.textContent = card.getAttribute("data-description");
            modal.style.display = "flex";
            document.body.style.overflow = "hidden"; // prevent scroll while modal open
          }, 420);
        } catch (err) {
          // Fallback: open modal immediately if anything goes wrong
          modalTitle.textContent = card.getAttribute("data-title");
          modalDesc.textContent = card.getAttribute("data-description");
          modal.style.display = "flex";
          document.body.style.overflow = "hidden";
        }
      });
    });

   
    function scrollProjectsCenter(targetEl = null, offsetPx = -100) {
  const projects = document.getElementById('projects');
  if (!projects) return;
  const grid = projects.querySelector('.problem-grid');
  const target = targetEl || (grid && grid.querySelector('.card')) || grid || projects.querySelector('.card') || projects;
  if (!target) return;

  // If there is a scrollable wrapper, compute a scrollTop that centers the target inside it.
  const wrapper = document.getElementById('wrapper') || document.scrollingElement || document.documentElement;
      try {
        const wrapperRect = wrapper.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();
        const wrapperScrollTop = wrapper.scrollTop;
        // distance from wrapper top to target top in pixels (relative to viewport)
        const offsetTop = targetRect.top - wrapperRect.top;
        // desired scroll so that target is vertically centered in wrapper
        const desiredScrollTop = wrapperScrollTop + offsetTop - (wrapper.clientHeight / 2) + (targetRect.height / 2) - offsetPx;
        wrapper.scrollTo({ top: desiredScrollTop, behavior: 'smooth' });
  } catch (err) {
    // fallback to scrollIntoView if something goes wrong
    target.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
  }

  // focus for accessibility
      try {
        target.setAttribute('tabindex', '-1');
        target.focus({ preventScroll: true });
      } catch (e) {
        target.focus();
      }
    }

    const projectsLink = document.querySelector('a[href="#projects"]');
    if (projectsLink) {
      projectsLink.addEventListener('click', e => {
        e.preventDefault();
        const projects = document.getElementById('projects');
        if (projects && projects.querySelector('.problem-grid')) {
          scrollProjectsCenter();
        } else {
          const obsP = new MutationObserver((mutations, observer) => {
            if (projects.querySelector('.problem-grid')) {
              scrollProjectsCenter();
              observer.disconnect();
            }
          });
          obsP.observe(projects, { childList: true, subtree: true });
        }
      });
    }

    closeBtn.addEventListener("click", () => {
      modal.style.display = "none";
      document.body.style.overflow = "auto";
    });

    window.addEventListener("click", e => {
      if (e.target === modal) {
        modal.style.display = "none";
        document.body.style.overflow = "auto";
      }
    });
    window.location.hash = "#projects";
  })
  .catch(error => console.error("Error loading projects.html:", error));

// Load skills.html into the #skills placeholder and initialize reveal animation

  fetch("skills.html")
    .then(response => response.text())
    .then(html => {
      // Parse and extract only the skills section (avoid injecting full <html>/<head>)
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const skillsSection = doc.querySelector('.skills-section') || doc.body;
      const target = document.getElementById('skills');
      if (!target) return;

      // Clear and append the parsed section
      target.innerHTML = '';
      target.appendChild(document.importNode(skillsSection, true));

      // Initialize reveal using IntersectionObserver with #wrapper as root (works when wrapper scrolls)
      const cards = Array.from(target.querySelectorAll('.phase-card'));
      const wrapper = document.getElementById('wrapper');
      if ('IntersectionObserver' in window && wrapper) {
        const obs = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.classList.add('visible');
              observer.unobserve(entry.target);
            }
          });
        }, { root: wrapper, threshold: 0.18 });
        cards.forEach(c => obs.observe(c));
      } else {
        // Fallback: simple scroll listener
        const revealCards = () => {
          const trigger = window.innerHeight * 0.9;
          cards.forEach(card => {
            const top = card.getBoundingClientRect().top;
            if (top < trigger) card.classList.add('visible');
          });
        };
        const scrollContainer = wrapper || window;
        scrollContainer.addEventListener('scroll', revealCards);
        window.addEventListener('resize', revealCards);
        revealCards();
      }
    })
    .catch(error => console.error('Error loading skills.html:', error));

    fetch("experience.html")
  .then(response => response.text())
  .then(data => {
    const target = document.getElementById("experience");
    target.innerHTML = data;

    // Initialize timeline item reveal using IntersectionObserver scoped to #wrapper
    const wrapper = document.getElementById('wrapper');
    const items = Array.from(target.querySelectorAll('.timeline-item'));
    if (items.length && 'IntersectionObserver' in window) {
      const tObs = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('active');
            obs.unobserve(entry.target);
          }
        });
      }, { root: wrapper, threshold: 0.28 });
      items.forEach(i => tObs.observe(i));
    } else {
      // fallback: just add active after small delay
      items.forEach(i => setTimeout(() => i.classList.add('active'), 120));
    }
  });


fetch("certifications.html")
  .then(response => response.text())
  .then(data => {
    const container = document.getElementById("certifications");
    container.innerHTML = data;

    // Get the grid container that holds all cards
    const grid = container.querySelector(".certifications-container");
    const filterButtons = container.querySelectorAll(".filter-btn");
    const certCards = Array.from(container.querySelectorAll(".cert-card"));

    filterButtons.forEach((button) => {
      button.addEventListener("click", () => {
        // Switch active button
        container.querySelector(".filter-btn.active")?.classList.remove("active");
        button.classList.add("active");

        const category = button.dataset.category.trim().toLowerCase();

        // Hide all cards first (add .hide class for animation)
        certCards.forEach((card) => card.classList.add("hide"));

        // Filter visible cards
        const filteredCards = certCards.filter((card) => {
          const cardCategory = card.dataset.category.trim().toLowerCase();
          return category === "all" || cardCategory === category;
        });

        // Wait for hide animation, then show filtered cards
        setTimeout(() => {
          certCards.forEach(card => card.style.display = "none");
          filteredCards.forEach(card => {
            card.style.display = "block";
            card.classList.remove("hide");
            grid.appendChild(card); // maintain order inside grid
          });
        }, 300); // matches your transition time in CSS
      });
    });
  })
  .catch(error => console.error("Error loading certifications:", error));

fetch("contact.html")
  .then(response => response.text())
  .then(data => {
    const container = document.getElementById("contact"); // ✅ load into contact section
    container.innerHTML = data;

    // form event listener inside the fetched content
    const form = container.querySelector("#contactForm");
    const formMessage = container.querySelector("#formMessage");

    if (form) {
      form.addEventListener("submit", function(e) {
        e.preventDefault();

        const name = form.querySelector("#name").value.trim();
        const email = form.querySelector("#email").value.trim();
        const message = form.querySelector("#message").value.trim();

        if (!name || !email || !message) {
          formMessage.textContent = "⚠️ Please fill out all fields.";
          formMessage.style.color = "#f87171";
          return;
        }

        const emailPattern = /^[^ ]+@[^ ]+\.[a-z]{2,3}$/;
        if (!email.match(emailPattern)) {
          formMessage.textContent = "⚠️ Please enter a valid email address.";
          formMessage.style.color = "#facc15";
          return;
        }

        formMessage.textContent = "✅ Message sent successfully!";
        formMessage.style.color = "#4ade80";
        form.reset();

        setTimeout(() => {
          formMessage.textContent = "";
        }, 4000);
      });
    }
  })
  .catch(error => console.error("Error loading contact form:", error));

</script>



</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Amit Kumar Yadav</title>
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>

<body>
  <div id="wrapper">
    <!-- Navbar -->
    <div class="container">
      <div class="navbar">
        <div class="logo-container">
          <img src="./Assets/A.png" class="logo" alt="Logo">
          <div class="logo-text">mit Kumar Yadav</div>
        </div>

        <div class="nav-items">
          <div><a href="#about">About</a></div>
          <div><a href="#skills">Skills</a></div>
          <div><a href="#projects">Projects</a></div>
          <div><a href="#certifications">Certifications</a></div>
          <div><a href="#contact">Contact</a></div>
        </div>
      </div>
    </div>

    <!-- Hero Section -->
    <div class="hero-section">
      <div class="faded-text">Amit Yadav</div>

      <div class="hero-section-left">
        <div class="hero-section-heading">Hello ðŸ‘‹</div>
        <div class="hero-section-subheading1">I am</div>
        <div class="hero-section-subheading2">Amit Kumar Yadav</div>
        <div class="hero-section-subheading3">
          I am a <span class="role"></span>
        </div>

        <div class="hero-section-description">
          A final-year student passionate about
        </div>
        <div>
          <span class="dynamic-text"></span>
        </div>

        <div class="btn-pink" id="btn">Hire me</div>
      </div>

 <div class="hero-section-right">
                    <div class="absolute icons icon-dots">
                        <img src="./Assets/dots.png" alt="" />
                      </div>
                      <div class="absolute icons icon-cube">
                        <img src="./Assets/cube.png" alt="" />
                      </div>
                      <div class="absolute icons icon-circle">
                        <img src="./Assets/circle.png" alt="" />
                      </div>
                      <div class="absolute icons icon-zigzag">
                        <img src="./Assets/zigzags.png" alt="" />
                      </div>
                      <div class="absolute icons icon-plus">
                        <img src="./Assets/plus.png" alt="" />
                      </div>
                      <div class="user-image">
                        <img src="./Assets/Amit1.jpeg" alt="" />
                      </div>
                </div>

</div>




  <div class="section-decor before">
    <div class="curve left"></div>
    <div class="curve right"></div>
  </div>

  <div id="about" class="section-with-curves"></div>

  <div class="section-decor between">
    <div class="curve left"></div>
    <div class="curve right"></div>
  </div>

  <div id="skills" class="section-with-curves"></div>

  <div class="section-decor between">
    <div class="curve left"></div>
    <div class="curve right"></div>
  </div>

  <div id="projects" class="section-with-curves"></div>

  <div class="section-decor after">
    <div class="curve left"></div>
    <div class="curve right"></div>
  </div>


  <!-- Popup Modal -->
  <div class="modal" style="display: none;">
    <div class="modal-content">
      <span class="close-btn">&times;</span>
      <h2 id="modal-title"></h2>
      <h4>Description</h4>
      <p id="modal-desc"></p>
    </div>
  </div>

  <!-- Typed.js Animation -->
  <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12"></script>
  <script>
    // (removed) previously we forced scroll-to-top on load which prevented restoring hashed navigation on refresh

    var typed = new Typed(".dynamic-text", {
      strings: [
        "Machine Learning",
        "AI",
        "Automation",
        "Cloud Computing",
        "Python Development"
      ],
      loop: true,
      typeSpeed: 100,
      backSpeed: 60,
      backDelay: 1000,
      showCursor: true,
      cursorChar: "|"
    });


fetch("about.html")
  .then(response => response.text())
  .then(data => {
    document.getElementById("about").innerHTML = data;

    // When clicking the About nav link, scroll the about card to the center of the viewport
    function scrollAboutCenter() {
      const about = document.getElementById('about');
      if (!about) return;
      const card = about.querySelector('.about-card') || about;
      // Use scrollIntoView so it scrolls the nearest scrollable ancestor (the #wrapper)
      card.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
      // focus for accessibility (preventScroll true to avoid jumping)
      try {
        card.setAttribute('tabindex', '-1');
        card.focus({ preventScroll: true });
      } catch (e) {
        // older browsers may not support options
        card.focus();
      }
    }

    const aboutLink = document.querySelector('a[href="#about"]');
    if (aboutLink) {
      aboutLink.addEventListener('click', e => {
        e.preventDefault();
        const about = document.getElementById('about');
        if (about && about.querySelector('.about-card')) {
          scrollAboutCenter();
        } else {
          // wait until about content is inserted
          const obs = new MutationObserver((mutations, observer) => {
            if (about.querySelector('.about-card')) {
              scrollAboutCenter();
              observer.disconnect();
            }
          });
          obs.observe(about, { childList: true, subtree: true });
        }
      });
    }

  })

  

fetch("projects.html")
  .then(response => response.text())
  .then(data => {
    document.getElementById("projects").innerHTML = data;
    // Initialize modal functionality
    const modal = document.querySelector(".modal");
    const modalTitle = document.getElementById("modal-title");
    const modalDesc = document.getElementById("modal-desc");
    const closeBtn = document.querySelector(".close-btn");

    document.querySelectorAll(".view-btn").forEach(btn => {
      btn.addEventListener("click", e => {
        e.preventDefault();
        const card = e.target.closest(".card");
        // Scroll the clicked card into the same centered position we use for the Projects link.
        // Use the same offset (-100) so visual placement matches expectations.
        try {
          scrollProjectsCenter(card, -100);
          // Give the smooth scroll a moment to start/complete visually before showing the modal.
          setTimeout(() => {
            modalTitle.textContent = card.getAttribute("data-title");
            modalDesc.textContent = card.getAttribute("data-description");
            modal.style.display = "flex";
            document.body.style.overflow = "hidden"; // prevent scroll while modal open
          }, 420);
        } catch (err) {
          // Fallback: open modal immediately if anything goes wrong
          modalTitle.textContent = card.getAttribute("data-title");
          modalDesc.textContent = card.getAttribute("data-description");
          modal.style.display = "flex";
          document.body.style.overflow = "hidden";
        }
      });
    });

    // No tech toggle needed; tech badges are shown inline in projects.html

    // Center projects grid (or first card) when Projects nav link is clicked
    // Centers a target project card (or the first grid card) inside the #wrapper.
    // Optional params:
    // - targetEl: an Element to center. If omitted the first card / grid is used.
    // - offsetPx: a vertical offset (positive moves content down, negative moves it up). Default -100.
    function scrollProjectsCenter(targetEl = null, offsetPx = -100) {
  const projects = document.getElementById('projects');
  if (!projects) return;
  const grid = projects.querySelector('.problem-grid');
  const target = targetEl || (grid && grid.querySelector('.card')) || grid || projects.querySelector('.card') || projects;
  if (!target) return;

  // If there is a scrollable wrapper, compute a scrollTop that centers the target inside it.
  const wrapper = document.getElementById('wrapper') || document.scrollingElement || document.documentElement;
      try {
        const wrapperRect = wrapper.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();
        const wrapperScrollTop = wrapper.scrollTop;
        // distance from wrapper top to target top in pixels (relative to viewport)
        const offsetTop = targetRect.top - wrapperRect.top;
        // desired scroll so that target is vertically centered in wrapper
        const desiredScrollTop = wrapperScrollTop + offsetTop - (wrapper.clientHeight / 2) + (targetRect.height / 2) - offsetPx;
        wrapper.scrollTo({ top: desiredScrollTop, behavior: 'smooth' });
  } catch (err) {
    // fallback to scrollIntoView if something goes wrong
    target.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
  }

  // focus for accessibility
      try {
        target.setAttribute('tabindex', '-1');
        target.focus({ preventScroll: true });
      } catch (e) {
        target.focus();
      }
    }

    const projectsLink = document.querySelector('a[href="#projects"]');
    if (projectsLink) {
      projectsLink.addEventListener('click', e => {
        e.preventDefault();
        const projects = document.getElementById('projects');
        if (projects && projects.querySelector('.problem-grid')) {
          scrollProjectsCenter();
        } else {
          const obsP = new MutationObserver((mutations, observer) => {
            if (projects.querySelector('.problem-grid')) {
              scrollProjectsCenter();
              observer.disconnect();
            }
          });
          obsP.observe(projects, { childList: true, subtree: true });
        }
      });
    }

    closeBtn.addEventListener("click", () => {
      modal.style.display = "none";
      document.body.style.overflow = "auto";
    });

    window.addEventListener("click", e => {
      if (e.target === modal) {
        modal.style.display = "none";
        document.body.style.overflow = "auto";
      }
    });
  })
  .catch(error => console.error("Error loading projects.html:", error));

// Load skills.html into the #skills placeholder and initialize reveal animation

  fetch("skills.html")
    .then(response => response.text())
    .then(html => {
      // Parse and extract only the skills section (avoid injecting full <html>/<head>)
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const skillsSection = doc.querySelector('.skills-section') || doc.body;
      const target = document.getElementById('skills');
      if (!target) return;

      // Clear and append the parsed section
      target.innerHTML = '';
      target.appendChild(document.importNode(skillsSection, true));

      // Initialize reveal using IntersectionObserver with #wrapper as root (works when wrapper scrolls)
      const cards = Array.from(target.querySelectorAll('.phase-card'));
      const wrapper = document.getElementById('wrapper');
      if ('IntersectionObserver' in window && wrapper) {
        const obs = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.classList.add('visible');
              observer.unobserve(entry.target);
            }
          });
        }, { root: wrapper, threshold: 0.18 });
        cards.forEach(c => obs.observe(c));
      } else {
        // Fallback: simple scroll listener
        const revealCards = () => {
          const trigger = window.innerHeight * 0.9;
          cards.forEach(card => {
            const top = card.getBoundingClientRect().top;
            if (top < trigger) card.classList.add('visible');
          });
        };
        const scrollContainer = wrapper || window;
        scrollContainer.addEventListener('scroll', revealCards);
        window.addEventListener('resize', revealCards);
        revealCards();
      }
    })
    .catch(error => console.error('Error loading skills.html:', error));
</script>



</body>
</html>